services:
  # service-1: web-app (this is our fast-api web-app)
  web-app:
    build: .
    image: user-api
    env_file:
      - .env # set all the environment variables from the .env file to the container
    container_name: user-api-app
    command: flask --app src/app.py run --host 0.0.0.0 #[ this will replace CMD command in the Dockerfile ]
    ports:
      - 5001:5000
    volumes:
      - ./src:/app/src # map the local directory to the container directory (for live code reloading) [NOTE: this replaces any COPY command in the Dockerfile]
    depends_on:
      - postgres # this will wait for the serviceName to be up before starting this service
      - redis
    networks:
      - my-network
    
  # service-2: db (this is our postgres database)
  postgres:
    image: postgres:16
    container_name: user-api-db
    environment:
      POSTGRES_USER: ${DB_USER} # load DB_USER env variable from .env file
      POSTGRES_PASSWORD: ${DB_PASSWORD} # load DB_PASSWORD env variable from .env file
      POSTGRES_DB: user_db
    ports:
      - 5432:5432
    networks:
      - my-network
    
  # service-3: redis (this is our Redis cache)
  redis:
    image: redis/redis-stack:latest
    container_name: user-api-redis
    ports:
      - 6379:6379
    networks:
      - my-network

# Define the network
networks:
  my-network:
    name: user-api-network
    driver: bridge
 

#  Now, we can run the following command to start the services: 
#  docker-compose up
 
#  This will start the services defined in the  docker-compose.yml  file. 
#  Now, we can access the web-app at  http://localhost:5001  and the database at  http://localhost:5432
